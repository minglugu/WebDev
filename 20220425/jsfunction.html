<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS Function</title>
</head>
<body>
    

    <!-- 1. 事件源 -->
    <!-- <button onclick="f()">请点击按钮</button> -->

    <!-- 建议这么写，将样式，结构和行为分开写 -->
    <!-- <button>这是一个按钮</button> -->

    <!-- <div class="one">
        hello 
    </div>

    <div id="two">
        hello two
    </div>

    <ul>
        <li>aaa</li>
        <li>bbb</li>
        <li>ccc</li>
        <li>sss</li>
        <li>rrr</li>

    </ul> -->

    <!-- innerHTML的演示 -->
    <!-- <div id="screen">
        <ul>
            <li>aaa</li>
            <li>aaa</li>
            <li>aaa</li>
    </ul>
    </div>
    <button id="btn">这是获取内容的按钮</button>
    <button id="btn2">这是修改内容的按钮</button> -->

    <!-- <div id="screen">0</div>
    <button id="plus">+</button> -->

    <!-- input 是单标签，所以用value属性，来获取内部的内容-->
    <!-- <input type="text" id="screen" value="0">
    <button id="plus">+</button> -->
    
    
    <script>


        // let plusButton = document.querySelector('#plus');
        // plusButton.onclick = function() {
        //     // 1. 获取到screen里面的值。
        //     let screen = document.querySelector('#screen');
        //     // let val = screen.innerHTML; // 字符串类型 
        //     let val = screen.value;
        //     val = parseInt(val);
        //     console.log(typeof(val));
        //     // 2. 把这个值 +1
        //     val++;
        //     // 3. 新的值写回screen里面
        //     screen.value = val;
        // }

        // let plusButton = document.querySelector('#plus');
        // plusButton.onclick = function() {
        //     // 1. 获取到screen里面的值。
        //     let screen = document.querySelector('#screen');
        //     let val = screen.innerHTML; // 字符串类型 
        //     val = parseInt(val);
        //     // 2. 把这个值 +1
        //     val++;
        //     // 3. 新的值写回screen里面
        //     screen.innerHTML = val;
        // }

        // 操作元素的内容
        // 通过对象里面的一个属性 innerHTML 来实现（元素里面包含的 html 代码是啥样的）
        // let button = document.querySelector('#btn');
        // button.onclick = function() {
        //     let screen = document.querySelector('#screen');
        //     // 获取元素的内容
        //     console.log(screen.innerHTML); // get the content whose id is screen
        //     // console.log(screen.innerHTML = 'hello, JS');
        // }

        // let button2 = document.querySelector('#btn2');
        // button2.onclick = function() {
        //     let screen = document.querySelector('#screen');
        //     screen.innerHTML = '<h1>这是修改后的内容</h1>';
        // }

        // 也可以这么写，但是要在html的button标签里面，这么写
        // <button onclick="f()">请点击俺按钮</button>
        // function f() {
        //     alert('hello');
        // }

        // let button = document.querySelector('button');
        // // 函数表达式：匿名函数赋值给onclick的属性
        // // 2. 事件类型。此处的function是回调函数
        // button.onclick = function() {
        //     // 事件的处理程序
        //     alert('hello');
        // }

        // JS 事件 event
        // 1. 事件源：哪个HTML 元素产生的事件
        // 2. 事件类型：鼠标点击，移动，窗口大小
        // 3. 事件的处理程序：当事件产生之后，执行啥样的js代码


        // 参数就是 css 的选择器
        // let div = document.querySelector('.one');
        // console.log(div);

        // let obj = document.querySelector('#two');
        // console.log(obj);

        // 后代选择器, 有多个 li 元素的时候，只会选中第一个
        // let obj1 = document.querySelector('ul li');
        // console.log(obj1);

        // 全部选中，用querySelectorAll,返回的是数组
        // 拿到的是对象
        // let objAll = document.querySelectorAll('ul li');
        // console.log(objAll);

        // DOM API：浏览器给 JS 提供的原生接口，不方便
        // 第三方API/frame: jQuery
        // Vue, React 等前端框架，还是对DOM的封装
        

        // 构造函数，是一种特殊的函数，批量创建出一组类似的对象
        // 函数内部用 this. 这样的方式来创建属性的时候。
        // function student() {

        // }

        // 这种写法为主
        // JS 中的对象，都是object
        // student object, {} 表示对象，键值对之间，用，分割；键和值之间，用：分割。
        // object.属性名
        // let student = {
        //     name: 'Cai',
        //     age: 20,
        //     height: 180,
        //     weight: 120,

        //     sing: function() {
        //         console.log('Ji, nitaimei!');
        //     },

        //     jump: function() {
        //         console.log('一段舞蹈');
        //     }
        // }
        // console.log(student.name); 
        // console.log(student.age);
        // student.sing();


        // scope, global and local. JS ES6 version
        // let: 块级作用域，block scope within {}
        // { }内部的代码，可以访问到{ }外面的代码
        // 并支持无限套娃:JS中的作用域，是支持‘逐级向上’查找的，找到了全局作用域 num。
        // 作用域链 scope chain
        // 在作用域不同节点上，存在多个同名的变量，那么优先找到最近的
        // let num = 10;
        // function hi2() {
        //     let num = 20;
        //     function hi(){
        //         console.log(num);
        //     }
        //     hi();
        // }
        // hi2();

        // 定义函数
        // function hello() {
        //     console.log('hello');
        // }

        // let f = hello; // 给 f 赋值。f是function类型的变量。hello是一个函数名，没有（），不是函数调用。这里只是一个单纯的函数赋值
        // console.log(typeof f);
        // console.log(f);

        // 以上定义函数和给函数赋值，是可以写在一起的
        // let f = function hello() {
        //     console.log('hello');
        // }

        // 定义的是没有名字的函数(匿名函数，或 lambda 表达式)，赋值给f2，用f2来调用
        // 实际开发中，比较常用的函数表达式的形式
        // let f1 = function() {
        //     console.log('hello1');
        // }

        // 通过 f 也能够调用到上面的 hello 函数
        // f1();

        // 支持多个变量的相加，变量数目小于等于7
        // typeof 来判断参数的类型
        // function add(a, b, c, d, e, f, g) {
        //     // if (a === undefined) {
        //     //     a = 0;
        //     // }
        //     a = a || 0;
        //     b = b || 0;
        //     c = c || 0;
        //     d = d || 0;
        //     e = e || 0;
        //     f = f || 0;
        //     g = g || 0;
        //     return  a + b + c + d + e + f + g; 
        // }
       // 最多支持 7 个参数的相加
    //    function add(a, b, c, d, e, f, g) {
    //         return a + b + c + d + e + f + g; 
    //    }
    //    // 后面的没有用到的变量，是undefined
    //    console.log(add(1 + 2)); // NaN
    //    console.log(add(1 + 2 + 3)); // NaN
    //    console.log(add(1 + 2 + 3 + 4)); // NaN

        // // 参数不用定义类型，因为是动态的
        // function add(x, y) {
        //     return x + y;
        // }

        // // 传入的参数是可以任意的，只要支持函数内部的逻辑。
        // let result = add(1, 2);
        // console.log(result);

        // result = add('hello ', 'world');
        // console.log(result);

        // result = add('hello', 10);
        // console.log(result);

        // // 定义函数，先写调用函数，再写函数，也可以。
        // function hello() {
        //     console.log('hello');
        // }

        // // 调用函数以后，才会打印
        // hello();
    </script>
</body>
</html>